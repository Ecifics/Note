# 计算机网络

[TOC]

## 一、概述

### 1.1 OSI模型

### 1.2 封装

在发送主机端，一个**应用层报文**（application-layer message）被传送给运输层。

运输层受到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成**运输层报文**（transport-layer segment），运输层报文因此而封装了应用层报文。附加信息包括允许接收端运输层向上向适当的应用程序教父报文的信息（例如差错检测信息）

运输层向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，产生了**网络层数据报**（network-layer datagram）。

该数据报接下来传递给链路层，链路层增加它自己的链路层首部信息并创建**链路层帧**（link-layer frame）。

每一层中，一个分组具有两种类型的字段：首部字段和有效载荷字段（payload field），其中有效载荷字段来自上一层的分组



### 1.3 OSI分层

+ 应用层
  + 应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。
  + 协议
    + HTTP
    + SMTP
+ 表示层
  + 数据处理（编解码、加密解密、压缩解压缩）
+ 会话层
  + 管理（建立、维护、重连）应用程序之间的会话

+ 运输层
  + 传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务
+ 网络层
  + 网络层负责为分组交换网上的不同主机提供通信服务

+ 链路层
  + 将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧

+ 物理层
  + 实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异




## 二、应用层

### 2.1 应用层协议原理

#### 进程通信

在操作系统的术语中，进行通信的实际上是进程（process）而不是程序。一个进程可以被认为是运行在端系统中的一个程序。当进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的操作系统确定。在两个不同端系统上的进程，通过跨越计算机网络交换报文(message)而相互通信。发送进程生成并向网络中发送报文；接收进程接收这些报文并可能通过将报文发送回去进行响应。



#### 进程与计算机网络之间的接口

进程通过一个称为**套接字**（socket）的软件接口向网络发送报文和从网络接收报文。我们考虑一个类比来帮助我们理解进程和套接字。进程可类比于一座房子，而它的套接字可以类比于它的门。当一个进程想向位于另外一台主机上的另一个进程发送报文时，它把报文推出该门（套接字）。该发送进程假定该门到另外一侧之间有运输的基础设施，该设施将把报文传送到目的进程的门口。一旦该报文抵达目的主机，它通过接收进程的门（套接字）传递，然后接收进程对该报文进行处理。

套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的**应用程序编程接口**(Application Programming Interface,API)。应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。应用程序开发者对于运输层的控制仅限于：

+ 选择运输层协议
+ 也许能设定几个运输层参数，如最大缓存和最大报文段长度等。

一旦应用程序开发者选择了一个运输层协议（如果可供选择的话），则应用程序就建立在由该协议提供的运输层服务之上。

> 套接字是IP地址和端口号的组合，例如192.168.1.101:6379



#### 进程寻址

为了向特定目的地发送邮政邮件，目的地需要有一个地址。类似地，在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息：

+ 主机的地址
+ 定义在目的主机中的接收进程的标识符。

在因特网中，主机由其**IP地址**（IP address）标识。IP地址是一个32比特的量且它能够唯一地标识该主机。除了知道报文送往目的地的主机地址外，发送进程还必须指定运行在接收主机上的接收进程（更具体地说，接收套接字)。因为一般而言一台主机能够运行许多网络应用，这些信息是需要的。目的地**端口号**(port number)用于这个目的。已经给流行的应用分配了特定的端口号。例如，Wb服务器用端口号80来标识。邮件服务器进程（使用SMTP协议)用端口号25来标识。

### 2.2 应用层协议

**应用层协议**定义了运行在不同端系统上的应用程序进程如何相互传递报文，特别定义了：

+ 交换的报文类型，例如请求报文和响应报文
+ 各种报文类型的语法，例如报文中各个字段及这些字段是如何描述的
+ 字段的语义，即这些字段中的信息的含义
+ 确定一个进程何时以及如何发送报文，对报文进行响应的规则



### 2.3 HTTP（HyperText Transfer Protocol）超文本传输协议

#### Web页面

Web页面是由对象组成的，一个对象是一个文件，例如一个HTML文件、一个JPEG图片或者一个Java小程序这样的可以通过URL地址寻址的文件



#### HTTP概况

HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户端传送Web页面的方式。当用户请求一个Web页面（例如点击一个超链接）时，浏览器向服务器发出对该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP相应报文进行响应

**HTTP使用TCP作为它的支撑运输协议（而不是在UDP上运行）**，HTTP客户端首先发一个与服务器的TCP连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。客户端向它的套接字接口发送HTTP请求报文并从它的套接字接口接收HTTP响应报文。相应的，服务器从它的套接字接口接收HTTP请求报文和它的套接字接口发送HTTP相应报文

HTTP是一个**无状态协议**（stateless protocol），HTTP服务器并不保存关于客户的任何信息。例如某个特定的客户在短短的几秒内两次请求同一个对象，服务器并不会因为刚刚为客户提供了该对象就不再做出反应，而是重新发送该对象，就像完全忘记不久前做的事一样。



#### 持续连接和非持续连接

非持续连接（non-persistent connection）：单个客户的每个请求和响应是一个单独的TCP进行发送的

持续连接：单个客户的所有的请求和响应都是同一个TCP连接发送的



#### 请求报文

<img src="https://notetuchuang-1305953527.cos.ap-chengdu.myqcloud.com/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.png" align="left" alt="HTTP请求报文的通用格式">



请求报文构成

+ 请求行（request line）：HTTP请求报文的第一行
  + 组成
    + 方法字段
    + URL字段
    + HTTP版本字段
+ 首部行（header line）：请求行之后的行
+ 实体（entity）



#### 相应报文

<img src="https://notetuchuang-1305953527.cos.ap-chengdu.myqcloud.com/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.png" align="left" alt="HTTP响应报文的通用格式">



响应报文构成

+ 状态行（status line）
  + 协议版本字段
  + 状态码
  + 状态信息
+ 首部行（header line）
+ 实体（entity body）

### Cookie

HTTP服务器是无状态的，那么一个用户在登录淘宝后，进入其他页面也需要重新登录，因为HTTP服务器并不保存任何客户的信息，第二次访问的时候，服务器并不知道你是否登录。

为了将访问的对象和具体用户联系起来的时候，可以使用cookie，**cookie主要用来分辨两个请求是否来自同一个客户端，以及用来保存一些状态信息**。例如我在Chrome上登录了力扣，访问力扣其他页面也不再需要登录，而我同时再用Edge登录力扣的时候，需要重新登录，因为我们使用客户端（浏览器）不同，cookie不一样。



cookie的实现需要四个组件

+ HTTP响应报文中的一个cookie首部行
+ HTTP请求报文中的一个cookie首部行
+ 在用户客户端系统中保留一个cookie文件，并有用户的客户端进行管理
+ 位于Web站点的一个后端数据库

当请求报文到达Web服务器后，Web服务器会产生一个唯一识别码，并以此作为索引在他的数据库中产生一个表项。接下来Web服务器用一个包含例如`Set-cookie:13125`的首部HTTP响应报文对客户端进行响应。

当客户端受到HTTP响应报文之后，会将首部行中`Set-cookie:`值提取出来，并在它管理的cookie文件中添加一行，包含服务期的主机名和对应的cookie识别码。

当客户端访问站点时，会查询cookie文件中是否对这个站点的识别码，如果有就将该识别码放在HTTP请求报文中的cookie首部航中，例如`Cookie:13125`。当站点从请求报文中读到对应的cookie首部行字段后，就可以判断是哪个用户了。

## 三、运输层

### 3.1 概述

**运输层协议是在端系统中实现而不是在路由器中实现，并且运输层协议只工作在端系统中**。

在发送端，运输层将发送应用程序进程接收到的报文转换成运输层分组，也就是运输层**报文段**（segment），是通过将应用层报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段并向目的地发送

### 3.1 因特网提供的运输服务

因特网为应用程序提供了两种运输层协议，即UDP和TCP，当为因特网创建一个新的引用时，首先要做出的决定是，选择UDP还是选择TCP，每个协议都为调用它们的应用提供了不同的服务集合

+ TCP服务
  + 面向连接的服务
    + 在应用层数据报文开始流动之前，TCP让客户和服务器相互交换运输层控制信息。这些所谓的握手过程提示客户和服务器，让它们为大量分组的到来做好准备。在握手阶段后，一个TCP连接就在两个进程的套接字之间建立了。这条连接时全双工的，即连接双方的进程可以在此连接上同时进行报文手法。当应用程序结束报文发送时，必须拆除该连接
    + 连接是全双工的，也就是连接双方的进程可以同时向对方发送报文
  + 可靠的数据传送服务
    + 通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能依靠TCP将相同的字节流交付给收方的套接字，而没有字节的丢失和冗余
  + 拥塞控制机制
  + 流量控制服务，以消除发送方是接收方缓存溢出的可能性
  + 分组首部开销大，UDP报文的首部只有8个字节，而TCP有20个字节
  + 提供全双工服务，客户端和服务器可以同时向对方发送消息
  + TCP连接是点对点，也就是一对一的
  + 提供差错恢复，即重传
+ UDP服务
  + 无连接服务，TCP需要进过三次握手后才能发送数据，而UDP不需要任何准备即可进行数据传输
  + 不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无连接的，因此在两个进程通信前没有握手过程。
  + UDP协议提供的是一种不可靠数据传送服务，当进程将报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程，不仅如此，到达接收进程的报文可能是乱序到达的
  + UDP没有包括拥塞控制机制，所以UDP的发送端可以用它选定的任何速率向其下层（网络层）注入数据
  + 分组首部开销少，UDP报文的首部只有8个字节，而TCP有20个字节
  + 提供差错检测，但是对查错恢复无能为力


> TCP安全
> 无论是TCP还是UDP**都没有提供任何加密机制**,这就是说发送进程传进其套接字的数据，与网络传送到目的进程的数据相同。也就是说如果某发送进程以明文方式（没有加密）发送了一个口令进入它的套接字，该明文口令将经过发送方与接收方之间的所有链路传送，这就可能在任何中间链路中被嗅探和发现。
>
> 因为隐私和其他安全问题对许多应用而言已经成为至关重要的问题，所以因特网已经研制了TCP的加强版本（**并不是运输层的第三种协议，而是在应用层上实现的**），称为**安全套接字层**（Secure Sockets Layer， SSL）。用SSL加强后的TCP不仅能够做传统TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。
>
> 如果应用程序要使用SSL的服务，它需要在该应用程序的客户端和服务器端包括SSL代码(利用现有的、高度优化的库和类)。SSL有它自己的套接字API,这类似于传统的TCP套接字API。当一个应用使用SSL时，发送进程向SSL套接字传递明文数据；在发送主机中的SSL则加密该数据并将加密的数据传递给TCP套接字。加密的数据经因特网传送到接收进程中的TCP套接字。该接收套接字将加密数据传递给SSL,由其进行解密。最后，SSL通过它的SSL套接字将明文数据传递给接收进程。



### TCP快速重传

当发送方一个接一个发送大量的报文段，如果一个报文段丢失，就可能引起一个接一个的冗余ACK。如果TCP发送方接收到对相同数据的3个冗余ACK（一共收到对同一个数据的4个ACK，1个首次确认报文和3个冗余ACK），TCP就会执行**快速重传**，也就是在定时器过期之前重传丢失的报文段



### TCP连接

#### TCP报文段

<img src="https://notetuchuang-1305953527.cos.ap-chengdu.myqcloud.com/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84.png" align="left" alt="TCP报文段结构" height="400" width="500">

+ 32比特的**序号字段（sequence number field）**
  + TCP吧数据看成一个无结构、有序的字节流，因此序号是建立在字节流上，一个报文段的序号就是该报文段首字节的字节流编号。例如主机A上的一个进程想通过TCP连接向主机B上的一个进行发送一个数据流。主机A中将隐式地对数据流中的每一个字节编号。例如一个数据流包含500000个字节，其中MSS（最大报文段长度）为1000个字节，数据流的首字节编号是0，TCP将该数据流构建500个报文段，第一个报文段分配序号0，第二个报文分配序号1000，第三个报文段分配序号2000，以此类推。

+ 32比特的**确认号字段（acknowledgment number field）**
  + 如果主机A和B进行通信，主机A填充进报文段的确认号是主机A期望从主机B收到的下一个字节的序号
+ 16比特的**接收窗口字段（receive window field）**



#### 连接管理

<img src="https://notetuchuang-1305953527.cos.ap-chengdu.myqcloud.com/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%8F%E5%8E%86%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%8A%B6%E6%80%81.png" align="left" alt="TCP客户端经历三次握手状态">



<img src="https://notetuchuang-1305953527.cos.ap-chengdu.myqcloud.com/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%8F%E5%8E%86%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%8A%B6%E6%80%81.png" align="left" alt="TCP服务器经历三次握手状态">

## 四、网络层

### IP协议

IP的服务模型是**尽力而为交付服务**（best-effort delivery service）,它只是尽最大努力在通信的主机之间交付报文段，但它并不做任何保证，它不保证报文段的交付，不保证报文段的按需交付，不保证报文段中的数据的完整性。因此，IP被称为**不可靠服务**（unreliable service）



## 相关专业名词及其出处

DHCP（P224）：动态主机配置协议、即插即用协议或零配置协议，允许主机自动获取一个IP地址，而不需要系统管理员手动配置IP地址

MSS（P153）：最大报文段长度

MTU（P153）：最大传输单元

## 面试题

### 1. http1.0、http1.1和http2.0区别

+ http1.0
  + 默认采用**短连接**，HTTP/1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。每次发送请求的时候，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会导致网络的利用率非常低
  + HTTP/1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设一个请求响应一直不到达，那么下一个请求就不发送，就到导致阻塞后面的请求
+ http1.1
  + 默认采用**长连接**，**TCP连接默认不关闭，可以被多个请求复用**，例如就是电话打完之后，先不直接挂断，而是持续一小段时间，这一小段时间内，如果还有事情沟通可以再次进行沟通，客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接
  + HTTP/1.1版还引入了**管道机制（pipelining）**，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率，**但是服务端还是顺序执行的，效率还有提升的空间**
  + HTTP/1.1还加入了缓存处理，新的字段如cache-control，支持断点传输，以及增加了Host字段（使得一个服务器能够用来创建多个Web站点）

+ HTTP/2
  + 二进制分帧
    + **帧**：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成
    + **流：**存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID
    + HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。
    + **HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。**每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。
  + 多路复用
    + 多路复用，代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中
      + 同域名下所有通信都在单个连接上完成。
      + 单个连接可以承载任意数量的双向数据流。
      + 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。
  + 头部压缩
    + HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。HTTP/2对消息头进行压缩传输，能够节省消息头占用的网络的流量。
  + 服务器推送
    + 服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。就是员工事先把一些老板可能询问的事情提现发送到老板的手机（缓存）上。这样老板想要知道的时候就可以直接读取短信（缓存）了

### 2. TCP和UDP区别以及其应用场景

+ TCP和UDP区别
  + TCP是可靠传输,UDP是不可靠传输
    + 
  + TCP面向连接,UDP无连接
    + TCP是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程
  + TCP传输数据有序,UDP不保证数据的有序性;
  + TCP连接只能有两个端点（即两个套接字）也就是一对一，而UDP可以一对一也可以一对多甚至多对多的通信
