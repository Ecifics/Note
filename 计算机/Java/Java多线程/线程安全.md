# 线程安全和Monitor

## 一、线程安全

### 1.1 线程出现问题的根本原因分析

线程出现问题的根本原因是因为**线程上下文切换**，导致线程里的指令没有执行完就切换执行其它线程了，下面举一个例子

```java
public class Test {
	static int count = 0;
	public static void main(String[] args) throws InterruptedException {
	    Thread t1 = new Thread(()->{
	        for (int i = 1; i < 5000; i++){
	            count++;
	        }
	    });
	    Thread t2 =new Thread(()->{
	        for (int i = 1; i < 5000; i++){
	            count--;
	        }
	    });
	    t1.start();
	    t2.start();
	    t1.join(); // 主线程等待t1线程执行完
	    t2.join(); // 主线程等待t2线程执行完
	    
	    // main线程只有等待t1, t2线程都执行完之后, 才能打印count, 否则main线程不会等待t1,t2
	    // 直接就打印count的值为0
	    log.debug("count的值是{}",count);
	}
}
```

最后打印结果count不一定为0



### 1.2 问题的进一步描述

#### 1.2.1 临界区

临界区的概念：一段代码内如果**存在对共享资源的多线程读写操作**，那么称这段代码为**临界区**，线程间共享资源也称为临界资源

一个程序运行多线程本身是没有问题的，问题出现在多个线程共享资源(临界资源)的时候

- 多个线程同时对共享资源进行**读操作**本身也没有问题 -
- 问题出现在对对共享资源同时进行**读写操作**时就有问题了



#### 1.2.2 竞态条件

多个线程在临界区执行，那么由于**代码指令的执行顺序不确定而导致结果无法预测**，称为竞态条件



### 1.3 synchronized 解决方案

为了避免临界区中的竞态条件发生，由多种手段可以达到

- **阻塞式解决方案：** synchronized , Lock (ReentrantLock)
- **非阻塞式解决方案：** 原子变量 (CAS)

现在讨论使用`synchronized`来进行解决，即俗称的`对象锁`，它采用`互斥`的方式**让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换**

> 注意: 虽然Java 中`互斥`和`同步`都可以采用 `synchronized 关键字`来完成，但它们还是有区别的：
>
> - 互斥是保证临界区的竞态条件发生，**同一时刻只能有一个线程执行临界区的代码**
> - 同步是由于线程执行的先后，**顺序不同但是需要一个线程等待其它线程运行到某个点**。



#### 1.3.1 synchronized语法

```java
synchronized(对象) { // 线程1获得锁， 那么线程2的状态是(blocked)
 	临界区
}
```



#### 1.3.2 synchronized实例原理

- `synchronized`实际上利用对象锁保证了临界区代码的原子性，临界区内的代码在外界看来是不可分割的，**不会被线程切换所打断**



<img src="C:/Users/Ecifics/Desktop/Recent Files/笔记/计算机/Java/Java多线程/synchronized原理演示图.png">

你可以做这样的类比： 

+ synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人 进行计算，线程 t1，t2 想象成两个人 
+ 当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行 count++ 代码 
+ 这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切 换，阻塞住了 
+ 这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦）， 这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才 能开门进入 
+ 当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥 匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count-- 代码



synchronized 实际是用对象锁保证了临界区内代码的**原子性**，原子性也就是临界区内的代码对外是不可分割的，不会被线程切换所打断。



#### 1.3.3 synchronized 加在方法上

- **加在实例方法上, 锁对象就是对象实例**

```java
public class Demo {
	//在方法上加上synchronized关键字
	public synchronized void test() {
	
	}
	//等价于
	public void test() {
		synchronized(this) {
		
		}
	}
}
123456789101112
```

- **加在静态方法上, 锁对象就是当前类的Class实例**

```java
public class Demo {
	//在静态方法上加上synchronized关键字
	public synchronized static void test() {
	
	}
	//等价于
	public void test() {
		synchronized(Demo.class) {
		
		}
	}
}
```



### 1.4 变量的安全分析

```java
@Slf4j(topic = "guizy.EightLockTest")
public class EightLockTest {
    // 锁对象是EightLockTest.class类对象
    public static synchronized void a() {
        Thread.sleep(1000);
        log.debug("1");
    }

    // 锁对象是e2
    public synchronized void b() {
        log.debug("2");
    }

    public static void main(String[] args) {
        EightLockTest e1 = new EightLockTest();
        new Thread(() -> e1.a()).start();
        new Thread(() -> e1.b()).start();
    }
}
```

可以看出a方法锁住的是EightLockTest的class对象，而b方法锁住的是EightLockTest对象，故两个方法锁的对象不同，两个线程运行不会影响



```java
@Slf4j(topic = "guizy.EightLockTest")
public class EightLockTest {
    // 锁对象是EightLockTest.class类对象
    public static synchronized void a() {
        Thread.sleep(1000);
        log.debug("1");
    }

    // 锁对象是EightLockTest.class类对象
    public static synchronized void b() {
        log.debug("2");
    }

    public static void main(String[] args) {
        EightLockTest e1 = new EightLockTest();
        EightLockTest e2 = new EightLockTest();
        new Thread(() -> e1.a()).start();
        new Thread(() -> e2.b()).start();
    }
}
```

因为两个方法锁住的是EightLockTest的class对象，即使e1和e2是两个不同的对象，但是因为是同一个锁对象，所以会互斥



### 1.5 变量的线程安全分析

#### 1.5.1 成员变量和静态变量的线程安全分析 

- 如果变量没有在线程间共享，那么变量是安全的
- 如果变量在线程间共享
  - 如果只有`读操作`，则`线程安全`
  - 如果有`读写操作`，则这段代码是`临界区`，`需要考虑线程安全`

#### 1.5.2 局部变量线程安全分析 

- 局部变量（**局部变量被初始化为基本数据类型**）是安全的
- 但局部变量引用的对象则未必 （要看该对象是否被共享且被执行了读写操作）
  - 如果该对象没有逃离方法(在方法内定义)的作用范围，它是线程安全的
  - 如果该对象逃离方法的作用范围，需要考虑线程安全

#### 1.5.3 局部变量线程安全的情况 

- 局部变量表是存在于栈帧中, 而虚拟机栈中又包括很多栈帧, 虚拟机栈是线程私有的;
- 局部变量（局部变量被初始化为基本数据类型）是安全的，示例如下

```java
public static void test1() {
     int i = 10;
     i++;
}
```

每个线程调用test1()方法时局部变量i会在每个线程的栈帧内存中创建多份，因此不存在共享



#### 1.5.3 思考 private或final的重要性 

提高线程的安全性

- 方法访问修饰符带来的思考: 如果把method2和method3 的方法修改为`public` 会不会导致线程安全问题; 分情况:

- 情况1：有其它线程调用 method2 和 method3

  - 只修改为public修饰,此时**不会出现线程安全**的问题, 即使线程2调用method2/3方法, 给2/3方法传过来的list对象也是线程2调用method1方法时,传递给method2/3的list对象, 不可能是线程1调用method1方法传的对象

- 情况2：在情况1 的基础上，为ThreadSafe 类添加子类，子类覆盖method2 或 method3方法，即如下所示： 从这个例子可以看出

  private或final提供安全的意义所在，请体会开闭原则中的【闭】

  - 如果改为public, 此时子类可以重写父类的方法, 在子类中开线程来操作list对象, 此时就会出现线程安全问题: 子类和父类共享了list对象
  - 如果改为private, 子类就不能重写父类的私有方法, 也就不会出现线程安全问题; 所以所private修饰符是可以避免线程安全问题.
  - 所以如果不想子类, 重写父类的方法的时候, 我们可以将父类中的方法设置为private, final修饰的方法, 此时子类就无法影响父类中的方法了!


```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
        list.add("1");
    }
    public void method3(ArrayList<String> list) {
        list.remove(0);
    }
}
class ThreadSafeSubClass extends ThreadSafe{
    @Override
    public void method3(ArrayList<String> list) {
        new Thread(() -> {
            list.remove(0);
        }).start();
    }
}
```



### 1.6 常见线程安全类

- String
- Integer
- StringBuffer
- Random
- Vector
- Hashtable
- java.util.concurrent 包下的类 JUC

这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的*, 也可以理解为它们的每个方法是原子的

- 它们的每个方法是原子的（方法都被加上了synchronized）
- 调用同一个方法是可以保证线程安全
- **但注意它们多个方法的组合不是原子的，所以可能会出现线程安全问题**，如果此时想要保证线程安全，在方法调用外面上锁，例如下面代码就是线程不安全的

```java
Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get("key") == null) {
	table.put("key", value);
}
```



### 1.7 不可变类的线程安全

- `String`和`Integer`类都是**不可变的类**，因为其类内部状态是不可改变的，也就是属性只能读不能修改，都被final修饰, 并且不能被继承，因此它们的方法都是线程安全的
- 肯定有些人他们知道String 有 replace，substring 等方法可以改变值，**其实调用这些方法返回的已经是一个新创建的对象了** (在字符串常量池中当修改了String的值,它不会再原有的基础上修改, 而是会重新开辟一个空间来存储)



### 1.8 示例分析-是否线程安全

#### 1.8.1 示例一

- `Servlet运行在Tomcat环境下并只有一个实例`，因此会被Tomcat的多个线程共享使用，因此存在成员变量的共享问题。

```java
public class MyServlet extends HttpServlet {
	 // 是否安全？  否：HashMap不是线程安全的，HashTable是
	 Map<String,Object> map = new HashMap<>();
	 // 是否安全？  是:String 为不可变类，线程安全
	 String S1 = "...";
	 // 是否安全？ 是
	 final String S2 = "...";
	 // 是否安全？ 否：不是常见的线程安全类
	 Date D1 = new Date();
	 // 是否安全？  否：引用值D2不可变，但是日期里面的其它属性比如年月日可变。与字符串的最大区别是Date里面的属性可变。
	 final Date D2 = new Date();
 
	 public void doGet(HttpServletRequest request,HttpServletResponse response) {
	  // 使用上述变量
	 }
}
12345678910111213141516
```

#### 1.8.2 示例二

- **分析线程是否安全**，先`对类的成员变量，类变量，局部变量`进行考虑，如果变量会在各个线程之间共享，那么就得考虑线程安全问题了，如果变量A引用的是线程安全类的实例，并且只调用该线程安全类的一个方法，那么该变量A是线程安全的的。下面对实例一进行分析：此类不是线程安全的。**`MyAspect`切面类只有一个实例，成员变量`start` 会被多个线程同时进行读写操作**
- **Spring中的Bean都是`单例`的, 除非使用`@Scope`修改为多例。**

```java
@Aspect
@Component 
public class MyAspect {
    // 是否安全？不安全, 因为MyAspect是单例的
    private long start = 0L;

    @Before("execution(* *(..))")
    public void before() {
        start = System.nanoTime();
    }

    @After("execution(* *(..))")
    public void after() {
        long end = System.nanoTime();
        System.out.println("cost time:" + (end-start));
    }
}
```

#### 1.8.3 示例三

- 此例是典型的三层模型调用，`MyServlet` `UserServiceImpl` `UserDaoImpl`类都只有一个实例，`UserDaoImpl`类中没有成员变量，`update`方法里的变量引用的对象不是线程共享的，所以是线程安全的；`UserServiceImpl`类中只有一个线程安全的`UserDaoImpl`类的实例，那么`UserServiceImpl`类也是线程安全的，同理 `MyServlet`也是线程安全的
- Servlet调用Service, Service调用Dao这三个方法使用的是`同一个线程`。

```java
public class MyServlet extends HttpServlet {
	 // 是否安全    是：UserService不可变，虽然有一个成员变量,
	 			// 但是是私有的, 没有地方修改它
	 private UserService userService = new UserServiceImpl();
	 
	 public void doGet(HttpServletRequest request, HttpServletResponse response) {
	 	userService.update(...);
	 }
}

public class UserServiceImpl implements UserService {
	 // 是否安全     是：Dao不可变, 其没有成员变量
	 private UserDao userDao = new UserDaoImpl();
	 
	 public void update() {
	 	userDao.update();
	 }
}

public class UserDaoImpl implements UserDao { 
	 // 是否安全   是：没有成员变量，无法修改其状态和属性
	 public void update() {
	 	String sql = "update user set password = ? where username = ?";
	 	// 是否安全   是：不同线程创建的conn各不相同，都在各自的栈内存中
	 	try (Connection conn = DriverManager.getConnection("","","")){
	 	// ...
	 	} catch (Exception e) {
	 	// ...
	 	}
	 }
}
```

#### 1.8.4 示例四

- 跟示例二大体相似，`UserDaoImpl`类中`有成员变量`，那么**多个线程可以对成员变量**`conn` 同时进行操作，`故是不安全的`

```java
public class MyServlet extends HttpServlet {
    // 是否安全
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}

public class UserServiceImpl implements UserService {
    // 是否安全
    private UserDao userDao = new UserDaoImpl();
    public void update() {
       userDao.update();
    }
}

public class UserDaoImpl implements UserDao {
    // 是否安全: 不安全; 当多个线程,共享conn, 一个线程拿到conn,刚创建一个连接赋值给conn, 此时另一个线程进来了, 直接将conn.close
    //另一个线程恢复了, 拿到conn干事情, 此时conn都被关闭了, 出现了问题
    private Connection conn = null;
    public void update() throws SQLException {
        String sql = "update user set password = ? where username = ?";
        conn = DriverManager.getConnection("","","");
        // ...
        conn.close();
    }
}
```

#### 1.8.5 示例五

- 跟示例三大体相似，`UserServiceImpl`类的`update方法中UserDao是作为局部变量存在`的，所以每个线程访问的时候都会新建有一个`UserDao`对象，新建的对象是线程独有的，所以`是线程安全的`

```java
public class MyServlet extends HttpServlet {
    // 是否安全
    private UserService userService = new UserServiceImpl();
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    public void update() {
        UserDao userDao = new UserDaoImpl();
        userDao.update();
    }
}
public class UserDaoImpl implements UserDao {
    // 是否安全
    private Connection = null;
    public void update() throws SQLException {
        String sql = "update user set password = ? where username = ?";
        conn = DriverManager.getConnection("","","");
        // ...
        conn.close();
    }
}
```

#### 1.8.6 示例六

- 私有变量sdf被暴露出去了, 发生了逃逸

```java
public abstract class Test {
    public void bar() {
        // 是否安全
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        foo(sdf);
    }
    public abstract foo(SimpleDateFormat sdf);
    public static void main(String[] args) {
        new Test().bar();
    }
}
```

- 其中`foo 的行为是不确定的`，可能`导致不安全的发生`，被称之为**外星方法**，**因为foo方法可以被重写，导致线程不安全。** 在String类中就考虑到了这一点，String类是`final`的，**子类不能重写它的方法。**

```java
public void foo(SimpleDateFormat sdf) {
    String dateStr = "1999-10-11 00:00:00";
    for (int i = 0; i < 20; i++) {
        new Thread(() -> {
            try {
                sdf.parse(dateStr);
            } catch (ParseException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```



#### 1.8.7 转账问题

- **转账练习**
  测试下面代码是否存在线程安全问题，并尝试改正

```java
package cn.itcast.n4.exercise;

import lombok.extern.slf4j.Slf4j;

import java.util.Random;

@Slf4j(topic = "c.ExerciseTransfer")
public class ExerciseTransfer {
    public static void main(String[] args) throws InterruptedException {
        Account a = new Account(1000);
        Account b = new Account(1000);
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                a.transfer(b, randomAmount());
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                b.transfer(a, randomAmount());
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        // 查看转账2000次后的总金额
        log.debug("total:{}", (a.getMoney() + b.getMoney()));
    }

    // Random 为线程安全
    static Random random = new Random();

    // 随机 1~100
    public static int randomAmount() {
        return random.nextInt(100) + 1;
    }
}

// 账户
class Account {
    private int money;

    public Account(int money) {
        this.money = money;
    }

    public int getMoney() {
        return money;
    }

    public void setMoney(int money) {
        this.money = money;
    }

    // 转账
    public void transfer(Account target, int amount) {
        synchronized(Account.class) {   //锁住Account类，因为涉及到A.money和B.money。
            if (this.money >= amount) {
                this.setMoney(this.getMoney() - amount);
                target.setMoney(target.getMoney() + amount);
            }
        }
    }
}
```





## 二、Monitor概念

### 2.1 Java 对象头 



- 普通对象以 32 位虚拟机为例,的对象头结构如下，其中的`Klass Word`为类型指针，指向方法区对应的Class对象；

![1583651065372](https://img-blog.csdnimg.cn/img_convert/ac7274e0d0dbe8c8b25f43f2aa1ed1d6.png)

- 数组对象
  ![1583651088663](https://img-blog.csdnimg.cn/img_convert/52c45594819f30fb8a9d6087682be254.png)
- **其中 Mark Word 结构为: `无锁(001)、偏向锁(101)、轻量级锁(00)、重量级锁(10)`**
  ![1583651590160](https://img-blog.csdnimg.cn/img_convert/0ffaeb7ddf7d71801bfd3eeb00754162.png)
- 所以一个对象的结构如下：
  ![1583678624634](https://img-blog.csdnimg.cn/img_convert/1844b5e3159baa3c8fb78478daa1580b.png)

### 2.2 Monitor 原理 (Synchronized底层实现-重量级锁)

Monitor被翻译为监视器或者管程

每个Java对象都可以关联一个(操作系统的)Monitor，如果使用synchronized给对象上锁（重量级），该对象头的MarkWord中就被设置为指向Monitor对象的指针

> 下图原理解释:
> - 当Thread1访问到synchronized(obj)中的共享资源的时候
>   - 首先会将synchronized中的`锁对象`中`对象头`的`MarkWord`去尝试指向`操作系统`的`Monitor`对象. 让锁对象中的MarkWord和Monitor对象相关联. 如果关联成功, 将obj对象头中的`MarkWord`的`对象状态`从01改为10。
>   - 因为Monitor没有和其他的obj的MarkWord相关联, 所以`Thread1`就成为了该`Monitor`的Owner(所有者)。
>   - 又来了个`Thread1`执行synchronized(obj)代码, 它首先会看看能不能执行该`临界区`的代码; 它会检查obj是否关联了Montior, 此时已经有关联了, 它就会去看看该Montior有没有所有者(Owner), 发现有所有者了(Thread2); `Thread1`也会和该Monitor关联, 该线程就会进入到它的`EntryList(阻塞队列)`;
>  - 当`Thread2`执行完`临界区`代码后, Monitor的`Owner(所有者)`就空出来了. 此时就会`通知`Monitor中的EntryList阻塞队列中的线程, 这些线程通过`竞争`, 成为新的`所有者`
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219192811839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![1583652360228](https://img-blog.csdnimg.cn/img_convert/98c3189e41fd654fe34ead273ec76eba.png)

- 刚开始时`Monitor`中的`Owner为null`
- **当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner**
- 当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入`EntryList`中变成`BLOCKED状态`
- **Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，`竞争时是非公平的 (仍然是抢占式)`**
- `图中 WaitSet 中的Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析`

> **注意：**
>
> - synchronized 必须是进入同一个锁对象的monitor 才有上述的效果; —> 也就要使用同一把锁
> - 不加 synchronized的锁对象不会关联监视器，不遵从以上规则
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219200615817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

> 它加锁就是依赖底层操作系统的 `mutex`相关指令实现, 所以会造成`用户态和内核态之间的切换`, 非常耗性能 !
>
> - 在JDK6的时候, 对synchronized进行了优化, 引入了`轻量级锁, 偏向锁`, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗~

### 2.3 synchronized原理

代码如下

```java
static final Object lock = new Object();
static int counter = 0;
public static void main(String[] args) {
    synchronized (lock) {
        counter++;
    }
}
```

- 反编译后的部分字节码
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219201521709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

> 注意：方法级别的 synchronized 不会在字节码指令中有所体现

### 2.4 synchronized 原理进阶

小故事

故事角色 

+ 老王 - JVM 
+ 小南 - 线程 
+ 小女 - 线程 
+ 房间 - 对象 
+ 房间门上 - 防盗锁 - Monitor 
+ 房间门上 - 小南书包 - 轻量级锁 
+ 房间门上 - 刻上小南大名 - 偏向锁 
+ 批量重刻名 - 一个类的偏向锁撤销到达 20 阈值 
+ 不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向 

小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样， 即使他离开了，别人也进不了门，他的工作就是安全的。 

但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女 晚上用。每次上锁太麻烦了，有没有更简单的办法呢？ 

小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因 此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是 自己的，那么就在门外等，并通知对方下次用锁门的方式。 

后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍 然觉得麻烦。 

于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那 么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦 掉，升级为挂书包的方式。 

同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。

后来他自己放假回老 家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字 后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包

### 2.5 轻量级锁 (用于优化Monitor这类的重量级锁）

轻量级锁的使用场景: 如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。

轻量级锁对使用者是透明的，即语法仍然是synchronized (jdk6对synchronized的优化)，假设有两个方法同步块，利用同一个对象加锁



**eg:** 线程A来操作临界区的资源, 给资源加锁,到执行完临界区代码,释放锁的过程, 没有线程来竞争, 此时就可以使用轻量级锁; **如果这期间有线程来竞争的话, 就会升级为重量级锁(synchronized)**

```java
static final Object obj = new Object();
public static void method1() {
     synchronized( obj ) {
         // 同步块 A
         method2();
     }
}
public static void method2() {
     synchronized( obj ) {
         // 同步块 B
     }
}
```

- 每次指向到synchronized代码块时，都会在栈帧中创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的MarkWord和锁对象引用reference
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219205033458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210119153328743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70

![1583755737580](https://img-blog.csdnimg.cn/img_convert/4d42844c6ddc19a6f94d954ae5a0cc79.png)

- 让锁记录中的Object reference指向锁对象地址，并且尝试用CAS(compare and sweep)将栈帧中的锁记录的(lock record 地址 00)替换Object对象的Mark Word，将Mark Word 的值(01)存入锁记录(lock record地址)中相互替换

  - 01 表示 `无锁` `(看Mark Word结构, 数字的含义)`
  - 00表示 `轻量级锁`
    ![1583755888236](https://img-blog.csdnimg.cn/img_convert/87f63c5373eed35d0bf65e0b510a7660.png)

**`重点:`**

- 如果cas替换成功, 获得了轻量级锁，那么对象的对象头储存的就是锁记录的地址和状态00，如下所示

  - **线程中锁记录, 记录了锁对象的锁状态标志; 锁对象的对象头中存储了锁记录的地址和状态, 标志哪个线程获得了锁**
  - 此时`栈帧`中存储了`对象的对象头`中的`锁状态标志`,年龄计数器,哈希值等; `对象的对象头中`就存储了`栈帧中锁记录的地址和状态00`, 这样的话`对象`就知道了是`哪个线程锁住自己`。
    ![1583755964276](https://img-blog.csdnimg.cn/img_convert/68c40cfc17498b1514fe31af8a896eaf.png)

- 如果cas替换失败，有两种情况: 

  - 如果是其它线程已经持有了该Object的轻量级锁，那么表示有竞争，将进入锁膨胀阶段，此时`对象Object`对象头中已经存储了别的线程的`锁记录地址 00`,指向了其他线程;

  - 如果是自己的线程已经执行了synchronized进行加锁，那么再添加一条 Lock Record 作为重入锁的计数– 线程多次加锁, 锁重入
    - 在上面代码中,`临界区中`又调用了`method2`, method2中又进行了一次`synchronized加锁操作`, 此时就会在`虚拟机栈`中再开辟一个method2方法对应的栈帧(栈顶), 该栈帧中又会存在一个`独立`的`Lock Record`, 此时它发现`对象的对象头中指向的就是自己线程中栈帧的锁记录`; 加锁也就失败了. 这种现象就叫做`锁重入`; 线程中有多少个锁记录, 就能表明该线程对这个对象加了几次锁 (锁重入计数)
      ![1583756190177](https://img-blog.csdnimg.cn/img_convert/9e36f456637862001c9c58ded2651a3b.png)

**轻量级锁解锁流程 :**

- 当`线程退出synchronized代码块`的时候，**如果获取的是`取值为 null 的锁记录` \**，表示有`锁重入`，这时\**重置锁记录**，`表示重入计数减一`
  ![1583756357835](https://img-blog.csdnimg.cn/img_convert/6e5c1ae4a693ec26d8c629fda57737c3.png)

- 当线程退出synchronized代码块的时候，如果

  ```
  获取的锁记录取值不为 null
  ```

  ，那么

  使用cas将Mark Word的值恢复给对象, 将直接替换的内容还原。

  - 成功则解锁成功 (轻量级锁解锁成功)
  - 失败，表示有竞争, 则`说明轻量级锁进行了锁膨胀`或`已经升级为重量级锁`，**进入重量级锁解锁流程 (Monitor流程)**

### 2.6 锁膨胀

- 如果在尝试`加轻量级锁`的过程中，`cas替换操作无法成功`，这是**有一种情况就是其它线程已经为这个对象加上了轻量级锁**，这是就要进行`锁膨胀(有竞争)`，**`将轻量级锁变成重量级锁。`**

- 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁, 此时发生`锁膨胀`
  ![1583757433691](https://img-blog.csdnimg.cn/img_convert/c3e0a92d418c70280fd2a0bb730eea82.png)

- 这时Thread-1加轻量级锁失败，进入锁膨胀流程

  - **因为`Thread-1`线程加轻量级锁失败, 轻量级锁没有阻塞队列的概念**, 所以此时就要`为对象申请Monitor锁(重量级锁)`，让`Object指向重量级锁地址10`，然后`自己进入Monitor的EntryList变成BLOCKED状态`

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219214748700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 当`Thread-0 线程`执行完`synchronized同步块`时，**使用cas将Mark Word的值恢复给对象头**, 肯定恢复失败,因为对象的对象头中存储的是`重量级锁的地址,状态变为10了`之前的是00, 肯定恢复失败。那么会`进入重量级锁的解锁过程`，即按照`Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的Thread-1线程`

### 2.7 自旋锁优化 (优化重量级锁竞争)

- 当发生重量级锁竞争的时候，还可以使用自旋来进行优化 (不加入Monitor的阻塞队列EntryList中)，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），**那么当前线程就可以不用进行上下文切换(持锁线程执行完synchronized同步块后,释放锁,Owner为空,唤醒阻塞队列来竞争,胜出的线程得到cpu执行权的过程)**就获得了锁
- 优化的点: 不用将`线程`加入到阻塞队列, 减少cpu切换.

1. `自旋重试成功的情况`
   ![1583758113724](https://img-blog.csdnimg.cn/img_convert/39ed180b2ab7eae1bc37ebba0a819c4c.png)
2. `自旋重试失败的情况`，**自旋了一定次数还是没有等到持锁的线程释放锁**, 线程2就会加入Monitor的阻塞队列(EntryList)
   ![1583758136650](https://img-blog.csdnimg.cn/img_convert/36162c78749df99fcd83560e3896aef0.png)

- **自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势**。
- 在 `Java 6 之后自旋锁是自适应`的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能

### 2.8 偏向锁 (biased lock) (用于优化轻量级锁重入)

> 场景: 没有竞争的时候, 一个线程中多次使用`synchronized`需要重入加锁的情况; **(只有一个线程进入临界区)**
>
> - 在经常需要竞争的情况下就不使用偏向锁, 因为偏向锁是默认开启的, 我们可以通过JVM的配置, 将偏向锁给关闭
> - **将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了**

- 在`轻量级的锁`中，我们可以发现，如果同一个线程对同一个对象进行`重入锁`时，**也需要执行CAS替换操作，这是有点耗时。**

- 那么java6开始引入了偏向锁，将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了

  - **升级为轻量级锁的情况 (会进行偏向锁撤销)** : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作成功了, 此时该线程就获得了锁对象。( `此时是交替访问临界区, 撤销偏向锁, 升级为轻量级锁`)
  - **升级为重量级锁的情况 (会进行偏向锁撤销)** : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作失败了, 此时说明发生了锁竞争。( `此时是多线程访问临界区, 撤销偏向锁, 升级为重量级锁`)

例如:

```java
public class Test {
    static final Object obj = new Object();

    public static void m1() {
        synchronized (obj) {
            // 同步块A
            m2();
        }
    }

    public static void m2() {
        synchronized (obj) {
            // 同步块B
            m3();
        }
    }

    public static void m3() {
        synchronized (obj) {
            // 同步块C
        }
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219223917148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219223934280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)



### 2.9 偏向锁状态 (了解)

- `运行时元数据（Mark Word）`的结构如下:
  ![1583762169169](https://img-blog.csdnimg.cn/img_convert/4b3e8d91dabdf79eb0ab250835c6bbc0.png)

+ `Normal：一般状态，没有加任何锁`，前面62位保存的是对象的信息，**最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）**

+ `Biased：偏向状态，使用偏向锁`，前面54位保存的当前线程的ID，**最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）**

+ `Lightweight：使用轻量级锁`，前62位保存的是锁记录的指针，**最后2位为状态（00）**

+ `Heavyweight：使用重量级锁`，前62位保存的是Monitor的地址指针，**最后2位为状态(10)**

[![img](https://img-blog.csdnimg.cn/img_convert/461b804dda9e6ee0737faf0519ca295c.png)](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png)

- 如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101
- 但是偏向锁默认是**有延迟**的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态
- 如果没有开启偏向锁，对象的Mark Word后三位应该是001

 **一个对象的创建过程**

- 如果开启了`偏向锁（默认是开启的）`，那么对象刚创建之后，**Mark Word 最后三位的值101**，并且这是它的`ThreadId`，`epoch`，`age(年龄计数器)`都是`0`，**在加锁的时候进行设置这些的值.**

- `偏向锁默认是延迟`的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加[虚拟机](https://so.csdn.net/so/search?q=虚拟机&spm=1001.2101.3001.7020)参数来禁用延迟：**`-XX:BiasedLockingStartupDelay=0`来禁用延迟**

- - **注意** : `处于偏向锁的对象解锁后，线程id仍存储于对象头中`

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219230315160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)
输出结果:
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219230503664.png)

- 测试禁用偏向锁：如果没有开启偏向锁，那么对象创建后最后三位的值为001，这时候它的hashcode，age都为0，hashcode是第一次用到hashcode时才赋值的。在上面测试代码运行时在添加 VM 参数`-XX:-UseBiasedLocking`禁用偏向锁（禁用偏向锁则优先使用轻量级锁），退出synchronized状态变回001

  - 禁止偏向锁, 虚拟机参数`-XX:-UseBiasedLocking`; 优先使用`轻量级锁`
  - 输出结果: 最开始状态为001，然后加轻量级锁变成00，最后恢复成001

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219231656738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

#### 2.9.1 撤销偏向锁-hashcode方法 (了解)

![在这里插入图片描述](https://img-blog.csdnimg.cn/202012192322377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 测试 `hashCode`：当`调用对象的hashcode方法`的时候就会`撤销这个对象的偏向锁`，**因为使用偏向锁时没有位置存`hashcode`的值了**

------

#### 2.9.2 撤销偏向锁-发生锁竞争 (升级为重量级锁)

**偏向锁、轻量级锁的使用条件, 都是在于多个线程没有对同一个对象进行`锁竞争`的前提下, 如果有`锁竞争`,此时就使用重量级锁。**

- 这里我们演示的是`偏向锁`撤销, 变成`轻量级锁`的过程，**那么就得满足轻量级锁的使用条件，就是没有线程对同一个对象进行`锁竞争`**，我们使用`wait` 和 `notify` 来辅助实现
- 虚拟机参数`-XX:BiasedLockingStartupDelay=0`确保我们的程序最开始使用了`偏向锁`

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219234125463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 输出结果，**最开始使用的是`偏向锁`**，**但是第二个线程尝试获取对象锁时(前提是: 线程一已经释放掉锁了,也就是执行完synchroized代码块)**，发现本来对象`偏向的是线程一`，那么偏向锁就会失效，加的就是`轻量级锁`
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219234530954.png)

#### 2.9.3 撤销偏向锁 - 调用 wait/notify (只有重量级锁才支持这两个方法)

> **（调用wait方法会导致锁膨胀而使用重量级锁）**

- **会使对象锁变成重量级锁**，因为`wait/notify方法之后重量级锁才支持`



### 2.10 加锁顺序

偏向锁-->轻量级锁-->重量级锁



### 2.11 批量重偏向

- 如果对象被多个线程访问，但是没有竞争 (上面撤销偏向锁就是这种情况: 一个线程执行完, 另一个线程再来执行, 没有竞争), 这时偏向T1的对象仍有机会重新偏向T2

  - 重偏向会重置Thread ID

- 当`撤销偏向锁101 升级为 轻量级锁00`超过`20次后（超过阈值）`，JVM会觉得是不是偏向错了，这时会在`给对象加锁时，重新偏向至加锁线程 (T2)。`

#### 2.11.1 批量撤销偏向锁

- 当撤销偏向锁的阈值超过40以后 ，就会将整个类的对象都改为**不可偏向**的

#### 2.11.2 同步省略 (锁消除)

> **同步省略**

1. **线程同步的代价是相当高的，同步的后果是`降低并发性和性能`**。
2. 在动态编译同步块的时候，`JIT编译器`可以`借助逃逸分析`来判断同步块所**使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。**
3. 如果没有，`那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。`这个**取消同步的过程就叫同步省略，也叫锁消除**。

- 例如下面的智障代码，`根本起不到锁的作用`

```java
public void f() {
    Object hellis = new Object();
    synchronized(hellis) {
        System.out.println(hellis);
    }
}
```

- 代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：

```java
public void f() {
    Object hellis = new Object();
	System.out.println(hellis);
}
```

**字节码分析**

- 代码

```java
public void f() {
    Object hellis = new Object();
    synchronized(hellis) {
        System.out.println(hellis);
    }
}
```

- 注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，**`同步省略操作是在解释运行时发生的`**

![image-20200729103650309](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI5MTAzNjUwMzA5LnBuZw?x-oss-process=image/format,png)



## 三、wait和notify 

### 3.1 wait和notify概述

#### 3.1.1 小故事

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220084049915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220084213239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

#### 5.1.2 wait、notify介绍 (必须要获取到锁对象, 才能调用这些方法)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220084652893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 当线程0获得到了`锁`, 成为`Monitor`的`Owner`, 但是此时它发现自己想要执行`synchroized代码块`的条件不满足; 此时它就调用`obj.wait`方法, 进入到Monitor中的`WaitSet`集合, 此时`线程0`的状态就变为`WAITING`

- 处于BLOCKED和WAITING状态的线程都为阻塞状态，CPU都不会分给他们时间片。但是有所区别：

  - `BLOCKED状态`的线程是在`竞争锁对象`时，`发现Monitor的Owner已经是别的线程了`**，此时就会进入EntryList中，并处于`BLOCKED状态`**
  - `WAITING状态`的线程是`获得了对象的锁`，但是自身的原因无法执行`synchroized的临界区资源`需要进入`阻塞状态`时，**锁对象调用了wait方法而进入了WaitSet中，处于`WAITING状态`**

- **`处于BLOCKED状态的线程会在锁被释放的时候被唤醒`**

- **`处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。然后它会进入到EntryList, 重新竞争锁`** (此时就将锁升级为`重量级锁`)

#### 5.1.3 API介绍

下面的三个方法都是`Object`中的方法; 通过`锁对象`来调用

- `wait()`: 让获得对象锁的线程到`waitSet`中一直等待
- `wait(long n)` : 当该等待线程没有被notify, 等待时间到了之后, 也会自动唤醒
- `notify()`: 让获得对象锁的线程, 使用锁对象调用`notify`去waitSet的等待线程中挑一个唤醒
- `notifyAll()` : 让获得对象锁的线程, 使用锁对象调用`notifyAll`去唤醒waitSet中所有的等待线程

它们都是`线程之间进行协作的手段`, 都属于`Object对象的方法`, **必须获得此对象的锁**, 才能调用这些方法

**注：只有当对象被锁以后(成为Owner)，才能调用wait和notify方法**

```java
public class Test1 {
	final static Object LOCK = new Object();
	public static void main(String[] args) throws InterruptedException {
        //只有在对象被锁住后才能调用wait方法
		synchronized (LOCK) {
			LOCK.wait();
		}
	}
}
123456789
```

- 演示`wait和notify`方法

```java
/**
 * Description:
 *
 * @author guizy
 * @date 2020/12/20 09:12
 */
@Slf4j(topic = "guizy.WaitNotifyTest")
public class WaitNotifyTest {
    static final Object obj = new Object();

    public static void main(String[] args) throws Exception {

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行...");
                try {
                    // 只有获得锁对象之后, 才能调用wait/notify
                    obj.wait(); // 此时t1线程进入WaitSet等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...");
            }
        }, "t1").start();

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行...");
                try {
                    obj.wait(); // 此时t2线程进入WaitSet等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...");
            }
        }, "t2").start();

        // 让主线程等两秒在执行,为了`唤醒`,不睡的话,那两个线程还没进入waitSet,主线程就开始唤醒了
        Thread.sleep(1000);
        log.debug("唤醒waitSet中的线程!");
        // 只有获得锁对象之后, 才能调用wait/notify
        synchronized (obj) {
            // obj.notify(); // 唤醒waitset中的一个线程
             obj.notifyAll(); // 唤醒waitset中的全部等待线程
        }
    }
}

```



notify()方法运行结果

```
08:44:55.127 [t1] DEBUG c.TestWaitNotify - running.....
08:44:55.131 [t2] DEBUG c.TestWaitNotify - running.....
08:44:57.111 [main] DEBUG c.TestWaitNotify - wake up thread on obj
08:44:57.111 [t1] DEBUG c.TestWaitNotify - running other code...
```



notifyAll()方法运行结果

```
08:43:52.791 [t1] DEBUG c.TestWaitNotify - running.....
08:43:52.794 [t2] DEBUG c.TestWaitNotify - running.....
08:43:54.782 [main] DEBUG c.TestWaitNotify - wake up thread on obj
08:43:54.782 [t2] DEBUG c.TestWaitNotify - running other code...
08:43:54.782 [t1] DEBUG c.TestWaitNotify - running other code...
```



### 4、Sleep(long n) 和 Wait(long n)的区别 `(重点)`

不同点

- `Sleep是Thread类的静态方法`，`Wait是Object的方法`，Object又是所有类的父类，所以所有类都有Wait方法。
- `Sleep在阻塞的时候不会释放锁`，而`Wait在阻塞的时候会释放锁 (不释放锁的话, 其他线程就无法唤醒该线程了)`
- Sleep方法不需要与synchronized一起使用，**而Wait方法需要与synchronized一起使用（wait/notify等方法, 必须要使用对象锁来调用）**

相同点

- `阻塞状态`都为`TIMED_WAITING (限时等待)`

sleep方法 / wait方法 测试

```java
/**
 * Description: 测试sleep不释放锁
 *
 * @author guizy
 * @date 2020/12/20 09:33
 */
@Slf4j(topic = "guizy.SleepTest")
public class SleepTest {

    public static final Object lock = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (lock) {
                log.debug("获得锁了");
                try {
                    // Thread.sleep(5000); // 主线程需要等5s才能获得到锁.所以所在sleep期间, 是不会释放锁的
                    lock.wait(5000); // 调用wait方法会立刻释放锁, 不然主线程就拿不到lock锁了, 当等待5s后程序才结束
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t1").start();

        // 主线程睡一秒
        Sleeper.sleep(1);
        synchronized (lock) {
            log.debug("获得锁了");
        }
}
```

sleep打印结果 : 表明在sleep期间, 锁是不会被释放的
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220094013513.png)
wait打印结果 : 当调用wait方法后, 锁就会被立刻释放
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220094129242.png)

### 5、wait/notify的正确使用

**Step 1 : 逐渐向下优化**

```java
@Slf4j(topic = "guizy.WaitNotifyTest")
public class WaitNotifyTest {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) {
        //思考下面的解决方案好不好，为什么？
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                if (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    Sleeper.sleep(2);   // 会阻塞2s, 不会释放锁
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                synchronized (room) {
                    log.debug("可以开始干活了");
                }
            }, "其它人").start();
        }

        Sleeper.sleep(1);
        new Thread(() -> {
            // 此时没有加锁, 所以会优先于其他人先执行
            // 这里能不能加 synchronized (room)？
            //synchronized (room) { // 如果加锁的话, 送烟人也需要等待小南睡2s的时间,此时即使送到了,小南线程也将锁释放了..
                hasCigarette = true;
                log.debug("烟到了噢！");
            //}
        }, "送烟的").start();
    }
}
```

- 不给`送烟线程加synchronized`输出情况

```java
10:16:32.311 guizy.WaitNotifyTest [小南] - 有烟没？[false]
10:16:32.318 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
10:16:33.318 guizy.WaitNotifyTest [送烟的] - 烟到了噢！
10:16:34.320 guizy.WaitNotifyTest [小南] - 有烟没？[true]
10:16:34.320 guizy.WaitNotifyTest [小南] - 可以开始干活了
10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.321 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.321 guizy.WaitNotifyTest [其它人] - 可以开始干活了
12345678910
```

- 给`送烟线程加synchronized`输出情况

```java
10:16:57.565 guizy.WaitNotifyTest [小南] - 有烟没？[false]
10:16:57.570 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
10:16:59.574 guizy.WaitNotifyTest [小南] - 有烟没？[false]
10:16:59.574 guizy.WaitNotifyTest [送烟的] - 烟到了噢！
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.576 guizy.WaitNotifyTest [其它人] - 可以开始干活了
123456789
```

+ 其它干活的线程，都要一直阻塞，效率太低
+ 小南线程必须睡足2s后才能醒来，就算烟提前送到了，也无法立刻醒来
+ 加了synchronized(room)后，好比小南在里面反锁了门睡觉，烟根本没有送进门，main没加synchronized就好像main线程是翻窗户进来的
+ 解决方法，使用wait-notify机制

**Step2:**

```java
@Slf4j(topic = "guizy.WaitNotifyTest")
public class WaitNotifyTest {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                if (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    try {
                        room.wait(); // 此时进入到waitset等待集合, 同时会释放锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                // 小南进入等待状态了, 其他线程就可以获得锁了
                synchronized (room) {
                    log.debug("可以开始干活了");
                }
            }, "其它人").start();
        }

        Sleeper.sleep(1);
        new Thread(() -> {
            synchronized (room) {
                hasCigarette = true;
                log.debug("烟到了噢！");
                room.notify();
            }
        }, "送烟的").start();
    }
}
11:00:51.840 guizy.WaitNotifyTest [小南] - 有烟没？[false]
11:00:51.847 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
11:00:51.847 guizy.WaitNotifyTest [其它人] - 可以开始干活了
11:00:51.847 guizy.WaitNotifyTest [其它人] - 可以开始干活了
11:00:51.847 guizy.WaitNotifyTest [其它人] - 可以开始干活了
11:00:51.847 guizy.WaitNotifyTest [其它人] - 可以开始干活了
11:00:51.847 guizy.WaitNotifyTest [其它人] - 可以开始干活了
11:00:52.847 guizy.WaitNotifyTest [送烟的] - 烟到了噢！
11:00:52.847 guizy.WaitNotifyTest [小南] - 有烟没？[true]
11:00:52.848 guizy.WaitNotifyTest [小南] - 可以开始干活了
```

如果此时除了小南在等待唤醒, 还有一个线程也在等待唤醒呢? 此时的`notify`方法会唤醒谁呢?
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220110553609.png)

**Step3:**

```java
@Slf4j(topic = "guizy.WaitNotifyTest")
public class WaitNotifyTest {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                if (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    try {
                        room.wait(); // 此时进入到waitset等待集合, 同时会释放锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        new Thread(() -> {
            synchronized (room) {
                log.debug("外卖送到没？[{}]", hasTakeout);
                if (!hasTakeout) {
                    log.debug("没外卖，先歇会！");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("外卖送到没？[{}]", hasTakeout);
                if (hasTakeout) {
                    log.debug("可以开始干活了");
                } else {
                    log.debug("没干成活...");
                }
            }
        }, "小女").start();

        Sleeper.sleep(1);
        new Thread(() -> {
            synchronized (room) {
                hasTakeout = true;
                log.debug("外卖到了噢！");
                room.notify();
            }
        }, "送外卖的").start();
    }
}

11:10:39.516 guizy.WaitNotifyTest [小南] - 有烟没？[false]
11:10:39.521 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
11:10:39.521 guizy.WaitNotifyTest [小女] - 外卖送到没？[false]
11:10:39.521 guizy.WaitNotifyTest [小女] - 没外卖，先歇会！
11:10:40.521 guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！
11:10:40.521 guizy.WaitNotifyTest [小南] - 有烟没？[false]
```

问题: 当外卖送到了, 却唤醒了`小南`, 此时就出现了问题
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220111243224.png)

**Step4:**

```java
new Thread(() -> {
 synchronized (room) {
	 hasTakeout = true;
	 log.debug("外卖到了噢！");
	 room.notifyAll();
 }
}, "送外卖的").start();
1234567
11:14:53.670 guizy.WaitNotifyTest [小南] - 有烟没？[false]
11:14:53.676 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
11:14:53.676 guizy.WaitNotifyTest [小女] - 外卖送到没？[false]
11:14:53.676 guizy.WaitNotifyTest [小女] - 没外卖，先歇会！
11:14:54.674 guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！
11:14:54.674 guizy.WaitNotifyTest [小女] - 外卖送到没？[true]
11:14:54.674 guizy.WaitNotifyTest [小女] - 可以开始干活了
11:14:54.675 guizy.WaitNotifyTest [小南] - 有烟没？[false]
12345678
```

还是唤醒了小南, 小南还是回去看看送来的是外卖还是烟. 很麻烦, 怎么解决?
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220111655619.png)

**Step5:**

- 使用`while循环`来解决`虚假唤醒`

```java
@Slf4j(topic = "guizy.WaitNotifyTest")
public class Main {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                while (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    try {
                        room.wait(); // 此时进入到waitset等待集合, 同时会释放锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        new Thread(() -> {
            synchronized (room) {
                log.debug("外卖送到没？[{}]", hasTakeout);
                while (!hasTakeout) {
                    log.debug("没外卖，先歇会！");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("外卖送到没？[{}]", hasTakeout);
                if (hasTakeout) {
                    log.debug("可以开始干活了");
                } else {
                    log.debug("没干成活...");
                }
            }
        }, "小女").start();

        Sleeper.sleep(1);
        new Thread(() -> {
            synchronized (room) {
                hasTakeout = true;
                log.debug("外卖到了噢！");
                room.notifyAll();
            }
        }, "送外卖的").start();
    }
}

11:19:25.275 guizy.WaitNotifyTest [小南] - 有烟没？[false]
11:19:25.282 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
11:19:25.282 guizy.WaitNotifyTest [小女] - 外卖送到没？[false]
11:19:25.283 guizy.WaitNotifyTest [小女] - 没外卖，先歇会！
11:19:26.287 guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！
11:19:26.287 guizy.WaitNotifyTest [小女] - 外卖送到没？[true]
11:19:26.287 guizy.WaitNotifyTest [小女] - 可以开始干活了
11:19:26.288 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
```

因为改为`while`如果唤醒之后, 就在while循环中执行了, 不会跑到while外面去执行"有烟没…", 此时小南就不需要每次notify, 就去看是不是送来的烟, 如果是烟, while就为false了.

## 四、 线程状态转换 

![img](https://img-blog.csdnimg.cn/img_convert/64146d2ab235481979b13ec4e9608fc5.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201221214359753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

假设有线程 Thread t

- 1、NEW <–> RUNNABLE
  - t.start()方法时, NEW --> RUNNABLE

- 2、RUNNABLE <–> WAITING
  - 线程用synchronized(obj)获取了对象锁后
    - 调用 obj.wait()方法时，t 线程进入waitSet中, 从`RUNNABLE --> WAITING`

    - 调用`obj.notify()`，`obj.notifyAll()`，`t.interrupt()`时, 唤醒的线程都进入entrySet阻塞队列成为BLOCKED状态, 在阻塞队列,和其他线程再进行竞争锁
      - **竞争锁成功**，t 线程从 `WAITING --> RUNNABLE`
      - **竞争锁失败**，t 线程从 `WAITING --> BLOCKED`

- 3、RUNNABLE <–> WAITING
  - 当前线程调用 t.join()方法时，当前线程从 `RUNNABLE --> WAITING` ,注意是**当前线程**在t线程对象在**waitSet**上等待
  - t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 `WAITING --> RUNNABLE`

- 4、RUNNABLE <–> WAITING
  - 当前线程调用 `LockSupport.park()` 方法会让当前线程从`RUNNABLE --> WAITING`
  - 调用 `LockSupport.unpark(目标线程)` 或调用了线程 的interrupt() ，会让目标线程从 `WAITING --> RUNNABLE`

- 5、RUNNABLE <–> TIMED_WAITING (带超时时间的wait)
  - t 线程用synchronized(obj)获取了对象锁后

    - 调用 `obj.wait(long n)` 方法时，t 线程从 `RUNNABLE --> TIMED_WAITING`

    - t 线程等待时间超过了 n 毫秒，或调用obj.notify() ， obj.notifyAll() ， t.interrupt()时; 唤醒的线程都到entrySet阻塞队列成为BLOCKED状态, 在阻塞队列,和其他线程再进行竞争锁

      - 竞争锁成功，t 线程从 **TIMED_WAITING --> RUNNABLE**
      - 竞争锁失败，t 线程从 **TIMED_WAITING --> BLOCKED**
- 6、RUNNABLE <–> TIMED_WAITING
  - 当前线程调用 `t.join(long n)`方法时，当前线程从 `RUNNABLE --> TIMED_WAITING` 注意是当前线程在t 线程对象的**waitSet**等待
  - 当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 `TIMED_WAITING --> RUNNABLE`
- 7、RUNNABLE <–> TIMED_WAITING
  - 当前线程调用 `Thread.sleep(long n)` ，当前线程从 `RUNNABLE --> TIMED_WAITING`
  - 当前线程等待时间超过了 n 毫秒或调用了线程的 **interrupt()** ，当前线程从 `TIMED_WAITING --> RUNNABLE`
- 8、RUNNABLE <–> TIMED_WAITING
  - 当前线程调用 `LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis)` 时，当前线程从 `RUNNABLE --> TIMED_WAITING`
  - 调用`LockSupport.unpark(目标线程) 或调用了线程 的 interrupt()` ，或是等待超时，会让目标线程从 `TIMED_WAITING--> RUNNABLE`
- 9、RUNNABLE <–> BLOCKED
- t 线程用 synchronized(obj) 获取了对象锁时如果`竞争失败`，从 `RUNNABLE –> BLOCKED`, 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –> RUNNABLE ，其它失败的线程仍然 BLOCKED
- 10、 RUNNABLE <–> TERMINATED
- 当前线程所有代码运行完毕，进入 TERMINATED



![在这里插入图片描述](https://img-blog.csdnimg.cn/20210202223351594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)



## 五、多把锁

小故事

- 一间大屋子有两个功能：`睡觉、学习，互不相干`。
- 现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低，小南获得锁之后, 学完习之后, 小女才能进来睡觉。

解决方法是准备多个房间（**多个对象锁**）

```java
@Slf4j(topic = "guizy.BigRoomTest")
public class BigRoomTest {
    public static void main(String[] args) {
        BigRoom bigRoom = new BigRoom();
        new Thread(() -> bigRoom.sleep(), "小南").start();
        new Thread(() -> bigRoom.study(), "小女").start();
    }
}

@Slf4j(topic = "guizy.BigRoom")
class BigRoom {
    public void sleep() {
        synchronized (this) {
            log.debug("sleeping 2 小时");
            Sleeper.sleep(2);
        }
    }

    public void study() {
        synchronized (this) {
            log.debug("study 1 小时");
            Sleeper.sleep(1);
        }
    }
}
// 相当于串行执行, 因为锁对象是整个屋子, 所以并发性很低
12:16:15.952 guizy.BigRoom [小南] - sleeping 2 小时
12:16:17.954 guizy.BigRoom [小女] - study 1 小时
```

- 改进让小南, 小女获取不同的锁即可

```java
@Slf4j(topic = "guizy.BigRoomTest")
public class BigRoomTest {
    private static final BigRoom sleepRoom = new BigRoom();
    private static final BigRoom studyRoom = new BigRoom();

    public static void main(String[] args) {
    	// 不同对象调用
        new Thread(() -> sleepRoom.sleep(), "小南").start();
        new Thread(() -> studyRoom.study(), "小女").start();
    }
}
1234567891011
// 因为使用的是不同的锁对象
12:18:50.580 guizy.BigRoom [小女] - study 1 小时
12:18:50.580 guizy.BigRoom [小南] - sleeping 2 小时
123
```

- 将锁的粒度细分
  - 好处，是可以增强并发度
  - 坏处，如果一个线程需要同时获得多把锁，就容易发生死锁

## 六、 活跃性

- 因为某种原因，使得代码一直无法执行完毕，这样的现象叫做 **活跃性**
- 活跃性相关的一系列问题都可以用 **`ReentrantLock`** 进行解决。

### 6.1 死锁 

- 有这样的情况：一个线程需要 **同时获取多把锁**，这时就容易发生死锁

如`线程1`获取`A对象锁`, `线程2`获取`B对象锁`; 

此时`线程1`又想获取`B对象锁`,` 线程2`又想获取`A对象锁`; 它们都等着对象释放锁, 此时就称为死锁

```java
public static void main(String[] args) {
	final Object A = new Object();
	final Object B = new Object();
	\
	new Thread(()->{
		synchronized (A) {
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			synchronized (B) {

			}
		}
	}).start();

	new Thread(()->{
		synchronized (B) {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			synchronized (A) {

			}
		}
	}).start();
}
```

### 6.2 发生死锁的必要条件 

- 互斥条件
  - 在一段时间内，`一种资源只能被一个进程所使用`
- 请求和保持条件
  - 进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源
- 不可抢占条件
  - 进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放
- 循环等待条件
  - 发生死锁时，必然存在一个进程——资源的循环链。

### 6.3 定位死锁的方法

方式一、JPS + JStack 进程ID

- jps先找到JVM进程
- jstack 进程ID
  - 在Java控制台中的`Terminal`中输入 **`jps`** 指令可以查看`正在运行中的进程ID`，使用 **`jstack 进程ID`** 可以查看进程状态。
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201223123336643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20201223123406253.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/20201223123554788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

方式二、 jconsole检测死锁

![img](https://img-blog.csdnimg.cn/img_convert/359638cf867dbe8d03da37c3e19fefe3.png)![img](https://img-blog.csdnimg.cn/img_convert/e9f23bd07142b38d856fef84e6ded641.png)

### 6.4 死锁举例 - [哲学家就餐问题]

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201223123802724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)
有五位哲学家，围坐在圆桌旁。

- 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。
- 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。
- 如果筷子被身边的人拿着，自己就得等待

当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。

```java
/**
 * Description: 使用synchronized加锁, 导致哲学家就餐问题, 死锁: 核心原因是因为synchronized的锁是不可打断的, 进入阻塞队列
 *                  需要一直等待别的线程释放锁
 *
 * @author guizy1
 * @date 2020/12/23 13:50
 */
@Slf4j(topic = "guizy.PhilosopherEat")
public class PhilosopherEat {
    public static void main(String[] args) {
        Chopstick c1 = new Chopstick("1");
        Chopstick c2 = new Chopstick("2");
        Chopstick c3 = new Chopstick("3");
        Chopstick c4 = new Chopstick("4");
        Chopstick c5 = new Chopstick("5");
        new Philosopher("苏格拉底", c1, c2).start();
        new Philosopher("柏拉图", c2, c3).start();
        new Philosopher("亚里士多德", c3, c4).start();
        new Philosopher("赫拉克利特", c4, c5).start();
        new Philosopher("阿基米德", c5, c1).start();
    }
}

@Slf4j(topic = "guizy.Philosopher")
class Philosopher extends Thread {
    final Chopstick left;
    final Chopstick right;

    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }

    @Override
    public void run() {
        while (true) {
            // 尝试获取左手筷子
            synchronized (left) {
                // 尝试获取右手筷子
                synchronized (right) {
                    eat();
                }
            }
        }
    }

    private void eat() {
        log.debug("eating...");
        Sleeper.sleep(0.5);
    }
}

class Chopstick{
    String name;

    public Chopstick(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "筷子{" + name + '}';
    }
}

// 程序只执行了下面的打印, 没有停止, 没有打印
15:04:55.346 guizy.Philosopher [苏格拉底] - eating...
15:04:55.346 guizy.Philosopher [亚里士多德] - eating...
15:04:55.850 guizy.Philosopher [亚里士多德] - eating...
15:04:55.850 guizy.Philosopher [苏格拉底] - eating...
15:04:56.351 guizy.Philosopher [亚里士多德] - eating...
15:04:56.852 guizy.Philosopher [亚里士多德] - eating...
```

通过`jps, jstack 进程id`查看死锁原因
`Found one Java-level deadlock:` 发现了一个Java级别的死锁

```java
Found one Java-level deadlock:
=============================
"阿基米德":
  waiting to lock monitor 0x000000001ae2a358 (object 0x00000000d6ea7420, a com.guizy.reentrantlock.Chopstick),
  which is held by "苏格拉底"
"苏格拉底":
  waiting to lock monitor 0x0000000017fb3518 (object 0x00000000d6ea7430, a com.guizy.reentrantlock.Chopstick),
  which is held by "柏拉图"
"柏???图":
  waiting to lock monitor 0x0000000017fb3468 (object 0x00000000d6ea7440, a com.guizy.reentrantlock.Chopstick),
  which is held by "亚里士多德"
"亚里士多德":
  waiting to lock monitor 0x0000000017fb0bd8 (object 0x00000000d6ea7450, a com.guizy.reentrantlock.Chopstick),
  which is held by "赫拉克利特"
"赫拉克利特":
  waiting to lock monitor 0x0000000017fb0c88 (object 0x00000000d6ea7460, a com.guizy.reentrantlock.Chopstick),
  which is held by "阿基米德"

Java stack information for the threads listed above:
===================================================
"阿基米德":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7420> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7460> (a com.guizy.reentrantlock.Chopstick)
"苏格拉底":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7430> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7420> (a com.guizy.reentrantlock.Chopstick)
"柏拉图":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7440> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7430> (a com.guizy.reentrantlock.Chopstick)
"亚里士多德":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7450> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7440> (a com.guizy.reentrantlock.Chopstick)
"赫拉克利特":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7460> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7450> (a com.guizy.reentrantlock.Chopstick)

Found 1 deadlock
```

### 6.5 避免死锁的方法

- 在线程使用锁对象时, 采用**固定加锁的顺序**, 可以使用Hash值的大小来确定加锁的先后
- 尽可能缩减加锁的范围, 等到操作共享变量的时候才加锁
- 使用可释放的定时锁 (一段时间申请不到锁的权限了, 直接释放掉)

![img](https://img-blog.csdnimg.cn/img_convert/b8a0466afe78fa85b406d66813c15c9b.png)

### 6.6 活锁

- `活锁`出现在两个线程 互相改变对方的结束条件，谁也无法结束。

##### 6.6.1 避免活锁的方法

- 在线程执行时，中途给予 不同的间隔时间, 让某个线程先结束即可。

##### 6.6.2 死锁与活锁的区别

- 死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时**线程阻塞**，**停止运行**的现象。
- 活锁是因为线程间修改了对方的结束条件，而导致代码**一直在运行**，却一直**运行不完**的现象。

## 6.7 饥饿

- 某些线程因为优先级太低，导致一直无法获得资源的现象。
- 在使用`顺序加锁`时，可能会出现`饥饿现象`