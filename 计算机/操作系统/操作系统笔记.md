# 操作系统

[TOC]



## 一、虚拟化

### 1.1 如果只运行一个程序，操作系统如何保证程序不做任何我们不希望它做的事情，同时仍然高效的运行？

可以基于权限的思想，分成用户模式和内核模式：

+ 在用户模式下，运行的代码会受到限制，例如进程不能发出I/O请求。但是内核会小心的向用户模式下运行的程序暴露某些关键功能（系统调用）供用户程序调用。此时，要执行系统调用，程序必须执行特殊的trap指令，指令跳入到内核并且提升为内核模式，之后系统调用可以执行任何的特权操作，完成后，调用返回指令回到调用的用户模式下的程序中，同时回到用户模式下。
+ 在内核模式下，运行的代码可以做任何事情，操作系统就是运行在内核模式下的。



### 1.2 如果我们运行一个程序，操作系统如何让它停下来并切换到另一个线程，从而实现虚拟化CPU共享？

+ 协作模式：等待系统调用
  + 操作系统相信程序会合理的运行，运行时间长的应用假定会定期放弃CPU，以便操作系统可以决定运行其他任务。
  + 在协作调度程序中，OS通过等待系统调用（例如当前程序执行yield方法，将CPU权限交出），或者某种非法操作，而且重新获得CPU的控制权。
+ 非协作方式：操作系统进行控制
  + 上下文切换



### 1.3 进程调度

#### 调度指标

+ 周转时间（turnaround time）：任务完成时间减去任务到达系统的时间
+ 响应时间（response time）：从任务到达到系统首次运行的时间

#### 调度策略

+ 先进先出（FIFO）
+ 最短任务优先（SJF，Shortest Job First），是一种非抢占式调度程序。
+ 最短完成时间优先（STCF，Shortest Time-to-Completion First）或抢占式最短作业优先（PSJF，Preemptive Shortest Job First）调度
+ 轮转（RR，Round-Robin）：一个线程执行完一个时间片后，切换到另一个线程执行。时间片长度必须是时钟中断周期的倍数。因为有上下文切换的开销，故时间片太短，会频繁发生上下文切换，成本非常高。
+ 多级反馈队列（MLFQ，Multi-level Feedback Queue）：
  + 由许多独立的队列组成，每个队列有不同的优先级，任何时刻，一个工作只能存在于一个队列中。
  + 规则：
    + 如果A优先级大于B，运行A
    + 如果A的优先级和B相等，A和B轮转运行
    + 工作进入系统时，放在最高优先级上
    + 一旦工作用完了其在某一层的时间配额（无论中间主动放弃过多少次CPU），降低其优先级（移入下一层的队列中）
    + 经过一段时间S，就将系统中所有工作重新加入到最高优先级队列
+ 比例份额（proportional-share）或公平份额（fair-share）：按照一定份额比例分配给不同线程不同份额，例如我们希望进程A占用75%的CPU时间，进程B占用25%的CPU时间，那么可以分配给A75的份额，B25的份额。之后我们随机产生一个在[1, 100]区间内的数，如果落在了[1,75]，则A运行；如果落在[76,100]，B运行。
+ 多处理器调度：对应当下多核处理器，也就是将多个CPU核组装在一块芯片上（并且每一个CPU核都有自己的工作缓存）
  + 单队列调度（SQMS，Single Queue Multiprocessor Scheduling）
  + 多队列调度（MQMS，Multi-Queue Multiprocessor Scheduling）








## 进程

### 创建进程

系统调用`fork()`用于创建进程，新创建的进程为子进程，原来的进程为父进程，**在C语言程序中子进程并不会从main()函数开头开始执行，而是从调用`fork()`函数之后开始执行**，就好像它也调用了fork()函数一样

子进程并不是完全拷贝了父进程，虽然子进程拥有自己的地址空间（私有内存）、寄存器以及程序计数器等，但是它从fork()返回的值是不同的，父进程获得的是新创建子进程的PID，而子进程获得的返回值是0。



## 堆（heap）和 栈（Stack）

堆用来管理动态分配的内存、用户管理的内存，堆内存的释放和申请是由程序员显式完成的

栈用来保存当前的函数调用状态分配空间给局部变量，传递参数和函数返回值，栈内存的释放和申请操作是编译器来隐式管理的，所以有时也被称为自动内存

堆是从上到下增长，栈是从下向上增长



## 内存管理单元（Memory Management Unit，MMU）

CPU中负责地址转换（虚拟内存到物理内存）的部分，每个MMU都需要基址寄存器和界限寄存器用于对地址转换和界限检查（防止越界）



## 分段

对于程序的内存区域，在堆和栈中间有一大块“空闲内存”，如果要将整个地址空间加载入内存，可能会浪费很大空间，于是可以对其进行**分段**。

在典型的地址空间里有三个逻辑不同的段：代码、栈和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中未使用部分占用物理内存。同时也需要对每一段配置一堆基址和界限寄存器
