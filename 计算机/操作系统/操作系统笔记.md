# 操作系统

[TOC]

## 一、虚拟化

### 1.1 CPU虚拟化

#### CPU虚拟化带来的挑战

+ 性能上：如何在不增加系统开销的情况下实现虚拟化？
+ 控制权：如何有效的运行进程，同时保留对CPU的控制权？



#### 解决方案-直接执行（Direct Execution）

直接执行顾名思义就是直接在CPU上运行程序即可。当操作系统需要运行这个程序时，将代码从磁盘中加载到内存中，找到程序入口（例如main函数），跳转到该处运行代码。



#### 解决方案-受限制的直接执行（Limited Direct Execution）

对于直接执行这种方案有两个问题：

+ 如何保证程序不会做我们不期望发生的事情？
+ 操作系统如何让其停下来切换到另一个进程，从而虚拟化CPU共享？

对于上述两个问题，操作系统可以提供受限制的直接执行：

+ 引入用户模式和内核模式。在用户模式下运行的代码会受到限制（例如无法进行I/O操作或者申请更多的内存等），但是操作系统会提供给在用户模式下运行的程序一些 trap 指令（instruction），该指令的执行会在内核模式下执行，执行完成后通过一个特殊的 return-from-trap 指令（instruction）返回给用户程序。
+ 时钟中断。每次中断后，操作系统重新获得了CPU的控制权，此时操作系统能够决定接下来做什么操作（例如可以停止当前线程，启动另一个线程）。
+ 上下文切换。如果调度程序决定需要开启一个新的线程，那么操作系统会保存当前进程所产生的的寄存器的值，并为即将执行的进程恢复一定的寄存器值，这样该进程就能从上次中断的状态时候继续执行下去。

> 在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的所有资源



#### 进程调度

##### 调度指标

+ 周转时间（turnaround time）：任务完成时间减去任务到达系统的时间
+ 响应时间（response time）：从任务到达到系统首次运行的时间

##### 调度策略

+ 先进先出（FIFO）
+ 最短任务优先（SJF，Shortest Job First），是一种非抢占式调度程序。
+ 最短完成时间优先（STCF，Shortest Time-to-Completion First）或抢占式最短作业优先（PSJF，Preemptive Shortest Job First）调度
+ 轮转（RR，Round-Robin）：一个线程执行完一个时间片后，切换到另一个线程执行。时间片长度必须是时钟中断周期的倍数。因为有上下文切换的开销，故时间片太短，会频繁发生上下文切换，成本非常高。
+ 多级反馈队列（MLFQ，Multi-level Feedback Queue）：
  + 由许多独立的队列组成，每个队列有不同的优先级，任何时刻，一个工作只能存在于一个队列中。
  + 规则：
    + 如果A优先级大于B，运行A
    + 如果A的优先级和B相等，A和B轮转运行
    + 工作进入系统时，放在最高优先级上
    + 一旦工作用完了其在某一层的时间配额（无论中间主动放弃过多少次CPU），降低其优先级（移入下一层的队列中）
    + 经过一段时间S，就将系统中所有工作重新加入到最高优先级队列
+ 比例份额（proportional-share）或公平份额（fair-share）：按照一定份额比例分配给不同线程不同份额，例如我们希望进程A占用75%的CPU时间，进程B占用25%的CPU时间，那么可以分配给A75的份额，B25的份额。之后我们随机产生一个在[1, 100]区间内的数，如果落在了[1,75]，则A运行；如果落在[76,100]，B运行。
+ 多处理器调度：对应当下多核处理器，也就是将多个CPU核组装在一块芯片上（并且每一个CPU核都有自己的工作缓存）
  + 单队列调度（SQMS，Single Queue Multiprocessor Scheduling）
  + 多队列调度（MQMS，Multi-Queue Multiprocessor Scheduling）



### 1.2 内存虚拟化

内存虚拟化给进程创造了一种假象，让每个进程认为自己拥有一段私有的内存用于存放自己的代码和数据。但实际上是许多程序共享着内存。

#### 内存虚拟化的目标

+ 透明（transparency）：程序不应该感知到内存被虚拟化的事实（虚拟地址到物理地址的映射过程），而是让程序觉得拥有它自己的私有物理内存
+ 效率（efficiency）：在时间上（不会使程序运行变慢）和空间上（不需要太多额外的内存）更高效。
+ 保护（protection）：当一个进程执行加载执行等操作时，不会影响到其他程序的或是操作系统本身的内存内容，也就是提供进程与进程以及进程与操作系统之间的隔离。



#### 地址转换-内存虚拟化的实现

地址转换：硬件每次对内存访问进行橱窗，将指令中的虚拟地址转换为物理地址，将应用程序引用重定位到实际的位置。



##### 应用一：动态重定位 

CPU提供两个硬件寄存器：基址（base）寄存器和界限（bound）寄存器。

进程中使用的内存引用的虚拟地址到物理地址的转换，是通过硬件将虚拟地址和基址寄存器的值相加得到物理地址。

> 有时我们将CPU负责地址转换的部分称为**内存管理单元**（Memory Management Unit，MMU）

界限及程序确保访问不会越界。界限寄存器有两种实现方式：

+ 记录地址空间的大小，硬件在将虚拟地址和基址寄存器进行求和前就检查要访问的虚拟地址是否超出这个界限。例如设置的值为4KB，那么只能访问0~4095之间的地址空间。
+ 记录地址空间结束的物理地址，硬件在转换虚拟地址为物理地址后才去检查是否超出界限。

因为这种重定位是在进程运行时发生的，同时可以在进程开始后改变其地址空间，故称为动态重定位。



###### 存在的问题

已经分配的内存中由于堆和栈并不大，他们之间的空间未被使用，造成了内存的浪费，造成了**内部碎片**（internal fragmentation）。



#### 分段-内存碎片的解决方案

通过基址寄存器和界限寄存器实现的虚拟内存十分浪费，堆栈中间未使用的内存会造成大量的内存碎片。

为了解决这个问题，分段应运而生。在内存管理单元（Memory Management Unit，MMU）中引入不知一对基址寄存器和界限寄存器，而是给每一个逻辑段（segment，代码、堆和栈）都分配一对儿。

如果在对某一个段进行访问的时候，超出了该段的边界，就会发生**segmentation fault**。

##### 分段带来的问题

分段在物理内存中并不连续的排列在一起，会造成**外部碎片**（external fragmentation）



#### 空闲空间管理-外部碎片的解决方案

##### 底层机制

操作系统会通过空闲列表来统计堆中还有哪些空间没有分配。

分割：当我们申请内存时，通过某种策略获取到某一段空闲内存时，如果申请的内存大小小于该空闲内存大小，那么会分割出申请大小的内存给程序，其余的保留在空闲列表中。

合并：当我们归还内存（例如在C语言中通过free释放内存操作）给操作系统，如果归还的内存块和其他空闲内存块相邻，那么会将他们合并为一个大的空闲内存块。



#### 基本策略

+ 最优匹配（best fit）：遍历整个空闲列表，找到和请求大小一样或者更大的空闲块加入候选者中，然后返回这些候选者中最小的一块。
+ 最差匹配（worst fit）：尝试找到最大的空闲块，并将其分割后返回给程序，而剩余的空闲块加入列表。
+ 首次匹配（first fit）：找到第一个符合要求的块就分割返回程序，剩余部分加入空闲列表中。
+ 下次匹配（next fit）：其他匹配方式都会从空闲列表开头开始遍历，而下次匹配从上一次查找结束的位置继续查找。












## 进程

### 创建进程

系统调用`fork()`用于创建进程，新创建的进程为子进程，原来的进程为父进程，**在C语言程序中子进程并不会从main()函数开头开始执行，而是从调用`fork()`函数之后开始执行**，就好像它也调用了fork()函数一样

子进程并不是完全拷贝了父进程，虽然子进程拥有自己的地址空间（私有内存）、寄存器以及程序计数器等，但是它从fork()返回的值是不同的，父进程获得的是新创建子进程的PID，而子进程获得的返回值是0。



## 堆（heap）和 栈（Stack）

堆用来管理动态分配的内存、用户管理的内存，堆内存的释放和申请是由程序员显式完成的

栈用来保存当前的函数调用状态分配空间给局部变量，传递参数和函数返回值，栈内存的释放和申请操作是编译器来隐式管理的，所以有时也被称为自动内存

堆是从上到下增长，栈是从下向上增长



## 内存管理单元（Memory Management Unit，MMU）

CPU中负责地址转换（虚拟内存到物理内存）的部分，每个MMU都需要基址寄存器和界限寄存器用于对地址转换和界限检查（防止越界）



## 分段

对于程序的内存区域，在堆和栈中间有一大块“空闲内存”，如果要将整个地址空间加载入内存，可能会浪费很大空间，于是可以对其进行**分段**。

在典型的地址空间里有三个逻辑不同的段：代码、栈和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中未使用部分占用物理内存。同时也需要对每一段配置一堆基址和界限寄存器
