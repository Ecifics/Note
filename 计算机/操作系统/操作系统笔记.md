# 操作系统

[TOC]

## 一、虚拟化

### 1.1 CPU虚拟化

#### CPU虚拟化带来的挑战

+ 性能上：如何在不增加系统开销的情况下实现虚拟化？
+ 控制权：如何有效的运行进程，同时保留对CPU的控制权？



#### 解决方案-直接执行（Direct Execution）

直接执行顾名思义就是直接在CPU上运行程序即可。当操作系统需要运行这个程序时，将代码从磁盘中加载到内存中，找到程序入口（例如main函数），跳转到该处运行代码。



#### 解决方案-受限制的直接执行（Limited Direct Execution）

对于直接执行这种方案有两个问题：

+ 如何保证程序不会做我们不期望发生的事情？
+ 操作系统如何让其停下来切换到另一个进程，从而虚拟化CPU共享？

对于上述两个问题，操作系统可以提供受限制的直接执行：

+ 引入用户模式和内核模式。在用户模式下运行的代码会受到限制（例如无法进行I/O操作或者申请更多的内存等），但是操作系统会提供给在用户模式下运行的程序一些 trap 指令（instruction），该指令的执行会在内核模式下执行，执行完成后通过一个特殊的 return-from-trap 指令（instruction）返回给用户程序。
+ 时钟中断。每次中断后，操作系统重新获得了CPU的控制权，此时操作系统能够决定接下来做什么操作（例如可以停止当前线程，启动另一个线程）。
+ 上下文切换。如果调度程序决定需要开启一个新的线程，那么操作系统会保存当前进程所产生的的寄存器的值，并为即将执行的进程恢复一定的寄存器值，这样该进程就能从上次中断的状态时候继续执行下去。

> 在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的所有资源



#### 进程调度

##### 调度指标

+ 周转时间（turnaround time）：任务完成时间减去任务到达系统的时间
+ 响应时间（response time）：从任务到达到系统首次运行的时间

##### 调度策略

+ 先进先出（FIFO）
+ 最短任务优先（SJF，Shortest Job First），是一种非抢占式调度程序。
+ 最短完成时间优先（STCF，Shortest Time-to-Completion First）或抢占式最短作业优先（PSJF，Preemptive Shortest Job First）调度
+ 轮转（RR，Round-Robin）：一个线程执行完一个时间片后，切换到另一个线程执行。时间片长度必须是时钟中断周期的倍数。因为有上下文切换的开销，故时间片太短，会频繁发生上下文切换，成本非常高。
+ 多级反馈队列（MLFQ，Multi-level Feedback Queue）：
  + 由许多独立的队列组成，每个队列有不同的优先级，任何时刻，一个工作只能存在于一个队列中。
  + 规则：
    + 如果A优先级大于B，运行A
    + 如果A的优先级和B相等，A和B轮转运行
    + 工作进入系统时，放在最高优先级上
    + 一旦工作用完了其在某一层的时间配额（无论中间主动放弃过多少次CPU），降低其优先级（移入下一层的队列中）
    + 经过一段时间S，就将系统中所有工作重新加入到最高优先级队列
+ 比例份额（proportional-share）或公平份额（fair-share）：按照一定份额比例分配给不同线程不同份额，例如我们希望进程A占用75%的CPU时间，进程B占用25%的CPU时间，那么可以分配给A75的份额，B25的份额。之后我们随机产生一个在[1, 100]区间内的数，如果落在了[1,75]，则A运行；如果落在[76,100]，B运行。
+ 多处理器调度：对应当下多核处理器，也就是将多个CPU核组装在一块芯片上（并且每一个CPU核都有自己的工作缓存）
  + 单队列调度（SQMS，Single Queue Multiprocessor Scheduling）
  + 多队列调度（MQMS，Multi-Queue Multiprocessor Scheduling）








## 进程

### 创建进程

系统调用`fork()`用于创建进程，新创建的进程为子进程，原来的进程为父进程，**在C语言程序中子进程并不会从main()函数开头开始执行，而是从调用`fork()`函数之后开始执行**，就好像它也调用了fork()函数一样

子进程并不是完全拷贝了父进程，虽然子进程拥有自己的地址空间（私有内存）、寄存器以及程序计数器等，但是它从fork()返回的值是不同的，父进程获得的是新创建子进程的PID，而子进程获得的返回值是0。



## 堆（heap）和 栈（Stack）

堆用来管理动态分配的内存、用户管理的内存，堆内存的释放和申请是由程序员显式完成的

栈用来保存当前的函数调用状态分配空间给局部变量，传递参数和函数返回值，栈内存的释放和申请操作是编译器来隐式管理的，所以有时也被称为自动内存

堆是从上到下增长，栈是从下向上增长



## 内存管理单元（Memory Management Unit，MMU）

CPU中负责地址转换（虚拟内存到物理内存）的部分，每个MMU都需要基址寄存器和界限寄存器用于对地址转换和界限检查（防止越界）



## 分段

对于程序的内存区域，在堆和栈中间有一大块“空闲内存”，如果要将整个地址空间加载入内存，可能会浪费很大空间，于是可以对其进行**分段**。

在典型的地址空间里有三个逻辑不同的段：代码、栈和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中未使用部分占用物理内存。同时也需要对每一段配置一堆基址和界限寄存器
